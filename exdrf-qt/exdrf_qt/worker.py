import logging
import threading
import time
from queue import Empty
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    overload,
    Deque,
    Hashable,
)
from uuid import uuid4

import sqlparse
from attrs import define, field
from PyQt5.QtCore import QObject, QThread, pyqtSignal
from sqlalchemy import Select
import heapq
from collections import deque

if TYPE_CHECKING:
    from exdrf_al.connection import DbConn
    from sqlalchemy.orm import Session

logger = logging.getLogger(__name__)


class WorkQueue:
    """A queue of work to be done by the worker thread."""

    heaps: Dict[Hashable, List[tuple[float, int, "Work"]]]
    active: Deque[Hashable]
    active_set: set[Hashable]
    seq: int
    lock: threading.Lock
    not_empty: threading.Condition

    def __init__(self) -> None:
        self.heaps = {}
        self.active = deque()
        self.active_set = set()
        self.seq = 0
        self.lock = threading.Lock()
        self.not_empty = threading.Condition(self.lock)

    def __len__(self) -> int:
        with self.lock:
            return sum(len(h) for h in self.heaps.values())

    def empty(self) -> bool:
        with self.lock:
            # active implies at least one non-empty class (after cleanup in get)
            return not self.active

    def put(self, item: "Work") -> None:
        cls = item.get_category()
        pr = item.get_priority()

        with self.not_empty:  # holds the same underlying lock
            heap = self.heaps.get(cls)
            if heap is None:
                heap = []
                self.heaps[cls] = heap

            heapq.heappush(heap, (-pr, self.seq, item))
            self.seq += 1

            if cls not in self.active_set:
                self.active.append(cls)
                self.active_set.add(cls)

            self.not_empty.notify()

    def get(self, block: bool = True, timeout: float | None = None) -> "Work":
        with self.not_empty:
            if not block:
                if not self.active:
                    raise Empty("get from empty WorkQueue")
            else:
                if not self.not_empty.wait_for(
                    predicate=lambda: bool(self.active), timeout=timeout
                ):
                    raise TimeoutError("Timed out waiting for item")

            # Clean up any empty classes at the front (defensive)
            while self.active:
                cls = self.active[0]
                heap = self.heaps.get(cls)
                if heap:
                    break
                self.active.popleft()
                self.active_set.discard(cls)

            if not self.active:
                raise Empty("get from empty WorkQueue")

            cls = self.active[0]
            heap = self.heaps[cls]
            _, _, item = heapq.heappop(heap)

            # rotate
            self.active.popleft()
            if heap:
                self.active.append(cls)
            else:
                self.active_set.discard(cls)

            return item

    def peek_class_order(self) -> list[Hashable]:
        with self.lock:
            return list(self.active)

    def sizes_by_class(self) -> dict[Hashable, int]:
        with self.lock:
            return {cls: len(h) for cls, h in self.heaps.items() if h}


@define(slots=True)
class Work:
    """A piece of work to be done by the worker thread.

    Attributes:
        statement: The SQLAlchemy select statement to execute.
        callback: The callback function to call with the result.
        req_id: The request ID to identify the work.
        result: The result of the work.
        error: The error generated by the work.
        use_unique: Whether to use unique() on the result.
    """

    statement: "Select" = field(repr=False)
    callback: Callable[["Work"], None] = field(repr=False)
    req_id: Any
    result: List[Any] = field(factory=list, repr=False)
    error: Any = field(default=None, repr=False)
    use_unique: bool = field(default=False, repr=False)

    def perform(self, session: "Session") -> None:
        """Perform the work."""
        if self.use_unique:
            self.result = list(session.scalars(self.statement).unique().all())
        else:
            self.result = list(session.scalars(self.statement))
        session.expunge_all()

    def get_category(self) -> str:
        """The category for the priority queue.

        The items in same category will be chosen in order of priority.
        """
        return ""

    def get_priority(self) -> int:
        """The priority for the priority queue.

        The items with higher priority will be chosen first.
        """
        return 10


class Relay(QObject):
    """A class that lives in the main thread and is informed about the
    completion of the worker thread.
    """

    worker: "Worker"
    data: Dict[Any, Work]
    queue: WorkQueue

    def __init__(self, cn: "DbConn", parent: Optional[QObject] = None):
        super().__init__(parent)
        self.data = {}
        self.queue = WorkQueue()
        self.worker = Worker(queue=self.queue, cn=cn, parent=self)
        self.worker.haveResult.connect(self.handle_result)

    def handle_result(self, work_id: Any):
        """Handle the result from the worker thread.

        Args:
            work_id: The ID of the work that was completed.
        """
        work = self.data.pop(work_id, None)
        if work is None:
            logger.debug("Work with ID %s not found in data", work_id)
            return

        try:
            work.callback(work)
            logger.log(1, "Work with ID %s completed successfully", work_id)
        except Exception as e:
            if isinstance(e, RuntimeError) and "has been deleted" in str(e):
                logger.debug(
                    "Work with ID %s completed, but the callback receiver "
                    "has been deleted.",
                    work_id,
                )
            else:
                logger.error(
                    "Exception while handling the work result: %s",
                    e,
                    exc_info=True,
                )

    def stop(self):
        """Stop the worker thread."""
        if self.worker.isRunning():
            self.worker.should_stop = True
            self.worker.quit()
            self.worker.wait()

    @overload
    def push_work(self, work: "Work") -> "Work": ...

    @overload
    def push_work(
        self,
        statement: "Select",
        callback: Callable[["Work"], None],
        req_id: Optional[Any] = None,
        use_unique: bool = False,
    ) -> "Work": ...

    def push_work(  # type: ignore[misc, assignment]
        self,
        statement_or_work: Any,
        callback: Any = None,
        req_id: Optional[Any] = None,
        use_unique: bool = False,
    ) -> "Work":
        """Add work to be done by the worker thread.

        Args:
            statement_or_work: Either a SQLAlchemy select statement or a Work
                object. If a Work object is provided, other parameters are
                ignored.
            callback: The callback function to call with the result. Required
                if statement_or_work is a Select statement.
            req_id: An optional request ID to identify the work. If one is not
                provided, a new one will be generated.
            use_unique: Whether to use unique() on the result.
        """
        if not self.worker.isRunning():
            self.worker.start()

        # Handle the case where a Work object is passed directly.
        if isinstance(statement_or_work, Work):
            work = statement_or_work
        else:
            # Create the work object from individual parameters.
            if callback is None:
                raise TypeError("callback is required when passing a statement")
            work = Work(
                statement=statement_or_work,
                callback=callback,
                req_id=req_id or uuid4().int,
                use_unique=use_unique,
            )

        # Save it locally.
        self.data[work.req_id] = work

        # Put it in the queue.
        self.queue.put(work)

        return work


class Worker(QThread):
    """The worker that reads the data from the database and emits the results
    to the relay object.

    The worker implements a priority queue to process the work in the order
    of priority among their classes.

    Attributes:
        queue: The queue to read from.
        should_stop: A flag to indicate if the worker should stop. It is set
            by the relay through the `stop()` method.
        cn: The database connection to use.

    Signals:
        haveResult: Emitted when the worker has a result to send to the relay.
    """

    queue: WorkQueue
    should_stop: bool
    cn: "DbConn"

    haveResult = pyqtSignal(object)

    def __init__(
        self, queue: WorkQueue, cn: "DbConn", parent: Optional[QObject] = None
    ):
        super().__init__(parent)
        self.should_stop = False
        self.queue = queue
        self.cn = cn
        self.setObjectName("ExdrfWorkerThread")

    def run(self) -> None:
        """The main function of the worker thread."""
        threading.current_thread().name = "ExdrfWorkerThread"
        while not self.should_stop:
            try:
                work: "Work" = self.queue.get(timeout=0.5)
            except (TimeoutError, Empty):
                time.sleep(0.25)
                continue

            try:
                with self.cn.session() as session:
                    work.perform(session)
                logger.log(
                    10,
                    "\n\nWork with ID %s completed in worker thread, "
                    "%d results from statement: %s\n\n",
                    work.req_id,
                    len(work.result),
                    work.statement,
                )
            except Exception as e:
                logger.error(
                    "Error while executing work: %s\n%s",
                    e,
                    sqlparse.format(
                        str(work.statement),
                        reindent=True,
                        keyword_case="upper",
                    ),
                    exc_info=True,
                )
                work.error = e

            self.haveResult.emit(work.req_id)
